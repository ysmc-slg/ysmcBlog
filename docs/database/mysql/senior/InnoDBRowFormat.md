---
title: InnoDB 行格式
autoPrev: engines
---

MySQL 服务器上负责对表中数据的读取和写入工作的部分是 存储引擎 ，而服务器又支持不同类型的存储引擎，比如 InnoDB 、 MyISAM 、 Memory 啥的，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，`真实数据在不同存储引擎中存放的格式一般是不同的`，甚至有的存储引擎比如 Memory 都不用磁盘来存储数据，也就是说关闭服务器后表中的数据就消失了。由于 InnoDB 是 MySQL 默认的存储引擎，也是我们最常用到的存储引擎，我们也没有那么多时间去把各个存储引擎的内部实现都看一遍，所以本集要唠叨的是使用 InnoDB 作为存储引擎的数据存储结构。

## 数据页简介

InnoDB 是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时， InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死。

InnoDB 采取的方式是：`将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB`。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

## InnoDB行格式

我们平时是以`记录`为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 `行格式` 或者 `记录格式` 。设计 `InnoDB` 存储引擎有4种不同类型的 `行格式` ，分别是 `Compact` 、 `Redundant` 、`Dynamic` 和 `Compressed` 行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。

### 指定行格式的语法

我们可以在创建或修改表的语句中指定 `行格式` ：

```sql
create table 表明 (列的信息) row_format = 行格式名称;

alter table 表明 row_format = 行格式
```

通过一下语句查看行格式

```sql
-- 查看默认行格式 mysql8 默认是Dynamic
SELECT @@innodb_default_row_format;

-- 使用如下语法查看具体表使用的行格式
SHOW TABLE STATUS like '表名';
```

比如我们在数据库里创建一个演示用的表 `record_format_demo` ，可以这样指定它的 行格式 ：

```sql
CREATE TABLE record_format_demo (
c1 VARCHAR(10),
c2 VARCHAR(10) NOT NULL,
c3 CHAR(10),
c4 VARCHAR(10)
) CHARSET=ascii ROW_FORMAT=COMPACT;
```

可以看到我们刚刚创建的这个表的 行格式 就是 `Compact`。

我们现在向这个表中插入两条记录：

```sql
INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'),('eeee', 'fff', NULL, NULL);
```

![image-20221121163830304](https://img.zxqs.top/20221121163831.png)

演示表的内容也填充好了，现在我们就来看看各个行格式下的存储方式到底有啥不同吧～

## Compact 行格式

![image-20221121165726262](https://img.zxqs.top/20221121165727.png)

一条完整的记录其实可以被分为 `记录的额外信息` 和 `记录的真实数据` 两大部分，下边我们详细看一下这两部分的组成。

**记录的额外信息**

这部分信息是 `服务器为了描述这条记录而不得不添加的一些信息`，这些额外信息分为3类，分别是 `变长字段长度列表`、`NULL 值列表` 和 `记录头信息`，我们分别看一下。

### 变长字段长度列表

我们知道 MySQL 支持一些变长的数据类型，比如 `varchar(m)`、`varbinary(m)`、各种 `text` 类型，各种 `blob` 类型，我们也可以把拥有这些数据类型的列称为 `变长字段`，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把 `MySQL` 服务器搞懵，所以这些变长字段占用的存储空间分为两部分：

1. 真正的数据内容
2. 占用的字节数

在 compact 行格式中，`把所有变长字段的真实数据占用的字节长度存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段占用的字节数按照列的顺序逆序存放`。

我们拿 `record_format_demo` 表中的第一条记录来举个例子。因为 `record_format_demo` 表的 `c1、c2、c4` 列都是 `varchar(10)` 类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为 `record_format_demo` 表中的各个列都使用的是 `ascii` 字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各变长字段内容的长度：

![image-20221130134249496](https://img.zxqs.top/20221130134257.png)

又因为这些长度值需要按照列的 `逆序` 存放，所以最后 `变长字段长度列表` 的字节串用十六进制就是（各个字节之间实际没有空格，用空格隔开只是方便理解）：

```java
01  03  04
```

把这个字节串组成的 `变长字段长度列表` 填入上边的示意图中的效果就是：

![image-20221130134718462](https://img.zxqs.top/20221130134719.png)

由于第一行记录中 c1、c2、c4 列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。具体用1还是2个字节来表示真实数据占用的字节数，InnoDB 有它的一套规则，我们首先声明一下 W、M 和 L 的意思：

1. 假设某个字符集中表示一个字符最多需要使用的字节数为 W，也就是使用 `show charset` 语句的结果中的 `Maxlen` 列，比方说 utf8 字符集中的 W 就是 3 ， gbk 字符集中的 W 就是 2 ， ascii 字符集中的 W 就是
2. 对于变长类型  `VARCHAR(M)` 来说，这种类型表示能存储最多 M 个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是 `M*W`。
3.  假设它实际存储的字符串占用的字节数是 L。

所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：

* 如果 `M*W <= 255`，那么使用1个字节（8个二进制位）来表示真正字符串占用的字节数。
  
  也就是说InnoDB在读`记录`的`变长字段长度列表`时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。
* 如果 M×W > 255 ，则分为两种情况：
  * 如果 L <= 127 ，则用1个字节来表示真正字符串占用的字节数。
  * 如果 L > 127 ，则用2个字节来表示真正字符串占用的字节数。
  
  InnoDB在读`记录`的`变长字段长度列表`时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个`单独的字段长度`还是`半个字段长度`呢？
  
  InnoDB 使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中（我们后边会唠叨），在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。

**总结一下就是说：**

如果该可变字段允许存储的最大字节数（ M*W ）超过255字节并且真实存储的字节数（ L ）超过127字节，则使用2个字节，否则使用1个字节。

另外需要注意的一点是，`变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的` 。也就是说对于第二条记录来说，因为 `c4` 列的值为 `NULL` ，所以第二条记录的 `变长字段长度列表` 只需要存储 `c1` 和 `c2` 列的长度即可。其中 `c1` 列存储的值为 'eeee' ，占用的字节数为 `4` ， `c2` 列存储的值为 'fff' ，占用的字节数为 `3` 。数字 4 可以用1个字节表示， 3 也可以用1个字节表示，所以整个 `变长字段长度列表` 共需2个字节。填充完 `变长字段长度列表` 的两条记录的对比图如下：

![image-20221130162642691](https://img.zxqs.top/20221130162643.png)

并不是所有记录都有这个 `变长字段长度列表` 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

### NULL 值列表

我们知道表中的某些列可能存储 NULL 值，如果把这些 NULL 值都放到 `记录的真实数据` 中存储会很占地方，所以 Compact 行格式把这些值为 NULL 的列同意管理起来，存储到 NULL 值列表中，他的处理过程是这样的：

1. 首先统计表中允许存储 NULL 的列有哪些。
   
   我们前面说过，主键列、被 `NOT NULL` 修饰的列都是不可以存储 NULL 值的，所以在统计的时候不会把这些列算进去。比如说表 `record_format_demo` 的3个列 c1、c3、c4 都是允许存储 NULL 值的，而 c2 列是被 `NOT NULL` 修饰，不允许存储 NULL 值。
2. `如果表中没有存储 NULL 的列，则 NULL 值列表也不存在了`，否则将每个允许存储 NULL 的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：
   * 二进制位的值为 1 时，代表该列的值为 null。
   * 二进制位的值为 0 是，代表该列的值不为 null
    
    因为表 record_format_demo 有三个值允许为 null 的列，所以这三个列和二进制位的对应关系就是这样：

    ![image-20221130224905129](https://img.zxqs.top/image-20221130224905129.png)

    再一次强调，二进制位按照列的顺序 `逆序` 排序，所以第一个列 c1 和最后一个二进制位对应
3. MySQL 规定 NULL 值列表必须用整数个字节位表示，如果使用的二进制位不是整数个字节，则在字节的高位补0

表 record_format_demo 只有3个值允许为 NULL 的列，对应3个二进制位，不足一个字节，所以在字节的高位补 0 ，效果就是这样：

![image-20221130225552726](https://img.zxqs.top/image-20221130225552726.png)

以此类推，如果一个表中有9个允许为 NULL ，那这个记录的 NULL 值列表部分就需要2个字节来表示了。

知道了规则之后，我们再返回头看表 record_format_demo 中的两条记录中的 `NULL值列表` 应该怎么储存。因为只有 c1 、 c3 、 c4 这3个列允许存储 NULL 值，所以所有记录的 NULL值列表 只需要一个字节。

对于第一条记录来说， c1 、 c3 、 c4 这3个列的值都不为 NULL ，所以它们对应的二进制位都是 0 ，画个
图就是这样

![image-20221130225716029](https://img.zxqs.top/image-20221130225716029.png)

所以第一条记录的 `NULL值列表` 用十六进制表示就是： 0x00 。

对于第二条记录来说， c1 、 c3 、 c4 这3个列中 c3 和 c4 的值都为 NULL ，所以这3个列对应的二进制位的情况就是：

![image-20221130225817216](https://img.zxqs.top/image-20221130225817216.png)

所以第二条记录的 NULL值列表 用十六进制表示就是： 0x06 。

所以这两条记录在填充了 `NULL值列表` 后的示意图就是这样：

![image-20221130230235065](https://img.zxqs.top/image-20221130230235065.png)

### 记录头信息

除了 `变长字段长度列表` 、 `NULL值列表` 之外，还有一个用于描述记录的 `记录头信息` ，它是由固定的 5 个字节组
成。 5 个字节也就是 40 个二进制位，不同的位代表不同的意思，如图：


![image-20221130230449755](https://img.zxqs.top/image-20221130230449755.png)

这些二进制位代表的详细信息如下表：

|名称|大小（单位：bit）|描述|
|----|----------------|------|
|预留位1|    1        |没有使用|
|预留位2|    1        |没有使用|
|delete_mask| 1       |   标记该记录是否被删除     |
|min_rec_mask| 1       |  B+ 树的每层非叶子节点中的最小记录都会添加该标记     |
|n_owned| 4       |  表示当前记录拥有的记录数     |
|heap_no| 13       |   表示当前记录在记录堆的位置信息     |
|record_type| 3       |   表示当前记录的类型， 0 表示普通记录， 1 表示B+树非叶子节点记录， 2 表示最小记录， 3 表示最大记录    |
|next_record| 16       |   表示下一条记录的相对位置     |

因为我们并不清楚这些属性详细的用法，所以这里就不分析各个属性值是怎么产生的了，之后我们遇到会详细看的。

### 记录的真实数据


对于 record_format_demo 表来说， 记录的真实数据 除了 `c1 、 c2 、 c3 、 c4` 这几个我们自己定义的列的数据以外， MySQL 会为每个记录默认的添加一些列（也称为 隐藏列 ），具体的列如下：

|    列明      | 是否必须 |   占用空间|           描述         |
|--------------|----------|-----------|------------------------|
|row_id        |    否    |   6字节   |   行ID，唯一标识一条记录|
|transaction_id|    是    |   6字节   |   事务ID                |
|roll_pointer  |    是    |   7字节   |   回滚指针              |


::: tip  提示

实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，我们为了美观才写成了row_id、transaction_id和roll_pointer。

:::

**这里需要提一下 InnoDB 表对主键的生成策略：**

优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个 `unique` 键作为主键，如果表中连 `unique` 键都没有定义的话，InnoDB 会为表默认添加一个名为 `row_id` 的隐藏列作为主键。所以我们从上表中可以看出：`InnoDB存储引擎会为每条记录都添加 transaction_id和 roll_pointer 这两个列，但是 row_id 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）`。这些隐藏列的值不用我们操心， InnoDB 存储引擎会自己帮我们生成的。

因为表 `record_format_demo` 并没有定义主键，所以 MySQL 服务器会为每条记录增加上述的3个列。现在看一下加上 `记录的真实数据` 的两个记录长什么样吧：


![image-20221201205604956](https://img.zxqs.top/image-20221201205604956.png)

看这个图的时候我们需要注意几点：



1. 表 `record_format_demo` 使用的是 ASCII 字符串，所以 `0x61616161` 就表示字符串 'aaaa'， `0x626262` 就表示字符串 'bbb' ，以此类推。
2. 注意第1条记录中 c3 列的值，它是 `CHAR(10)` 类型的，它实际存储的字符串是： 'cc' ，而 ASCII 字符集中的字节表示是 '0x6363' ，虽然表示这个字符串只占用了2个字节，但整个 c3 列仍然占用了10个字节的空间，除真实数据以外的8个字节的统统都用 `空格字符` 填充，`空格字符` 在 ascii 字符集的表示就是 0x20 。
3. 注意第2条记录中 c3 和 c4 列的值都为 NULL ，它们被存储在了前边的 NULL值列表 处，在记录的真实数据处就不再冗余存储，从而节省存储空间。


### CHAR(M)列的存储格式

`record_format_demo` 表的 c1、c2、c4 列的类型是 varchar(10)，而 c3 列的类型是 char(10)，我们说在 Cmopact 行格式下只会把边长类型的列的长度 `逆序` 存到 `边长字段长度列表` 中，就像这样：

![image-20221201211800885](https://img.zxqs.top/image-20221201211800885.png)

::: tip 

但是这只是因为我们的 `record_format_demo` 表采用的是 `ascii` 字符集，这个字符集是一个定长字符集，

也就是说表示一个字符采用固定的一个字节，如果采用变长的字符集（也就是表示一个字符需要的字节数不确定，比如 gbk 表示一个字符要 1-2 个字节、 utf8 表示一个字符要 1-3 个字节等）的话， 

c3 列的长度也会被存储到 `变长字段长度列表` 中，比如我们修改一下 `record_format_demo` 表的字符集：


:::

```sql
ALTER TABLE record_format_demo MODIFY COLUMN c3 CHAR(10) CHARACTER SET utf8;
```

修改该列字符集后记录的 `变长字段长度列表` 也发生了变化，如图：


![image-20221201213200758](https://img.zxqs.top/image-20221201213200758.png)

**注意：**

c3 列的字符长度是10，长度不可变,尽管值是 `cc`。所以存入 `变长字段长度列表` 的值是 0A（UTF8中1个英文字符表示一个字节，所以10转16进制就是0A）

这就意味着：`对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表`。


另外有一点还需要注意，变长字符集的 CHAR(M) 类型的列要求至少占用 M 个字节，而 VARCHAR(M) 却没有这个要
求。比方说对于使用 utf8 字符集的 CHAR(10) 的列来说，该列存储的数据字节长度的范围是10～30个字节。即
使我们向该列中存储一个空字符串也会占用 10 个字节，这是怕将来更新该列的值的字节长度大于原有值的字节
长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有
的记录空间成为所谓的碎片。