---
title: InnoDB 行格式
autoPrev: engines
---

MySQL 服务器上负责对表中数据的读取和写入工作的部分是 存储引擎 ，而服务器又支持不同类型的存储引擎，比如 InnoDB 、 MyISAM 、 Memory 啥的，不同的存储引擎一般是由不同的人为实现不同的特性而开发的，`真实数据在不同存储引擎中存放的格式一般是不同的`，甚至有的存储引擎比如 Memory 都不用磁盘来存储数据，也就是说关闭服务器后表中的数据就消失了。由于 InnoDB 是 MySQL 默认的存储引擎，也是我们最常用到的存储引擎，我们也没有那么多时间去把各个存储引擎的内部实现都看一遍，所以本集要唠叨的是使用 InnoDB 作为存储引擎的数据存储结构。

## 数据页简介

InnoDB 是一个将表中的数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的。而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时， InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么？不，那样会慢死。

InnoDB 采取的方式是：`将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB`。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

## InnoDB行格式

我们平时是以`记录`为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为 `行格式` 或者 `记录格式` 。设计 `InnoDB` 存储引擎有4种不同类型的 `行格式` ，分别是 `Compact` 、 `Redundant` 、`Dynamic` 和 `Compressed` 行格式，随着时间的推移，他们可能会设计出更多的行格式，但是不管怎么变，在原理上大体都是相同的。

### 指定行格式的语法

我们可以在创建或修改表的语句中指定 `行格式` ：

```sql
create table 表明 (列的信息) row_format = 行格式名称;

alter table 表明 row_format = 行格式
```

通过一下语句查看行格式

```sql
-- 查看默认行格式 mysql8 默认是Dynamic
SELECT @@innodb_default_row_format;

-- 使用如下语法查看具体表使用的行格式
SHOW TABLE STATUS like '表名';
```

比如我们在数据库里创建一个演示用的表 `record_format_demo` ，可以这样指定它的 行格式 ：

```sql
CREATE TABLE record_format_demo (
c1 VARCHAR(10),
c2 VARCHAR(10) NOT NULL,
c3 CHAR(10),
c4 VARCHAR(10)
) CHARSET=ascii ROW_FORMAT=COMPACT;
```

可以看到我们刚刚创建的这个表的 行格式 就是 `Compact`。

我们现在向这个表中插入两条记录：

```sql
INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'),('eeee', 'fff', NULL, NULL);
```

![image-20221121163830304](https://img.zxqs.top/20221121163831.png)

演示表的内容也填充好了，现在我们就来看看各个行格式下的存储方式到底有啥不同吧～

### Compact 行格式

![image-20221121165726262](https://img.zxqs.top/20221121165727.png)

一条完整的记录其实可以被分为 `记录的额外信息` 和 `记录的真实数据` 两大部分，下边我们详细看一下这两部分的组成。

**记录的额外信息**

这部分信息是 `服务器为了描述这条记录而不得不添加的一些信息`，这些额外信息分为3类，分别是 `变长字段长度列表`、`NULL 值列表` 和 `记录头信息`，我们分别看一下。

### 变长字段长度列表

我们知道 MySQL 支持一些变长的数据类型，比如 `varchar(m)`、`varbinary(m)`、各种 `text` 类型，各种 `blob` 类型，我们也可以把拥有这些数据类型的列称为 `变长字段`，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把 `MySQL` 服务器搞懵，所以这些变长字段占用的存储空间分为两部分：

1. 真正的数据内容
2. 占用的字节数

在 compact 行格式中，`把所有变长字段的真实数据占用的字节长度存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段占用的字节数按照列的顺序逆序存放`。

我们拿 `record_format_demo` 表中的第一条记录来举个例子。因为 `record_format_demo` 表的 `c1、c2、c4` 列都是 `varchar(10)` 类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为 `record_format_demo` 表中的各个列都使用的是 `ascii` 字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各变长字段内容的长度：

![image-20221130134249496](https://img.zxqs.top/20221130134257.png)

又因为这些长度值需要按照列的 `逆序` 存放，所以最后 `变长字段长度列表` 的字节串用十六进制就是（各个字节之间实际没有空格，用空格隔开只是方便理解）：

```java
01  03  04
```

把这个字节串组成的 `变长字段长度列表` 填入上边的示意图中的效果就是：

![image-20221130134718462](https://img.zxqs.top/20221130134719.png)

由于第一行记录中 c1、c2、c4 列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。具体用1还是2个字节来表示真实数据占用的字节数，InnoDB 有它的一套规则，我们首先声明一下 W、M 和 L 的意思：

1. 假设某个字符集中表示一个字符最多需要使用的字节数为 W，也就是使用 `show charset` 语句的结果中的 `Maxlen` 列，比方说 utf8 字符集中的 W 就是 3 ， gbk 字符集中的 W 就是 2 ， ascii 字符集中的 W 就是
2. 对于变长类型  `VARCHAR(M)` 来说，这种类型表示能存储最多 M 个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是 `M*W`。
3.  假设它实际存储的字符串占用的字节数是 L。

所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：

* 如果 `M*W <= 255`，那么使用1个字节（8个二进制位）来表示真正字符串占用的字节数。
  
  也就是说InnoDB在读`记录`的`变长字段长度列表`时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。
* 如果 M×W > 255 ，则分为两种情况：
  * 如果 L <= 127 ，则用1个字节来表示真正字符串占用的字节数。
  * 如果 L > 127 ，则用2个字节来表示真正字符串占用的字节数。
  
  InnoDB在读`记录`的`变长字段长度列表`时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个`单独的字段长度`还是`半个字段长度`呢？
  
  InnoDB 使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中（我们后边会唠叨），在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。

**总结一下就是说：**

如果该可变字段允许存储的最大字节数（ M*W ）超过255字节并且真实存储的字节数（ L ）超过127字节，则使用2个字节，否则使用1个字节。

另外需要注意的一点是，`变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的` 。也就是说对于第二条记录来说，因为 `c4` 列的值为 `NULL` ，所以第二条记录的 `变长字段长度列表` 只需要存储 `c1` 和 `c2` 列的长度即可。其中 `c1` 列存储的值为 'eeee' ，占用的字节数为 `4` ， `c2` 列存储的值为 'fff' ，占用的字节数为 `3` 。数字 4 可以用1个字节表示， 3 也可以用1个字节表示，所以整个 `变长字段长度列表` 共需2个字节。填充完 `变长字段长度列表` 的两条记录的对比图如下：

![image-20221130162642691](https://img.zxqs.top/20221130162643.png)

并不是所有记录都有这个 `变长字段长度列表` 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

### NULL 值列表

我们知道表中的某些列可能存储 NULL 值，如果把这些 NULL 值都放到 `记录的真实数据` 中存储会很占地方，所以 Compact 行格式把这些值为 NULL 的列同意管理起来，存储到 NULL 值列表中，他的处理过程是这样的：

1. 首先统计表中允许存储 NULL 的列有哪些。
   
   我们前面说过，主键列、被 `NOT NULL` 修饰的列都是不可以存储 NULL 值的，所以在统计的时候不会把这些列算进去。比如说表 `record_format_demo` 的3个列 c1、c3、c4 都是允许存储 NULL 值的，而 c2 列是被 `NOT NULL` 修饰，不允许存储 NULL 值。
2. `如果表中没有存储 NULL 的列，则 NULL 值列表也不存在了`，否则将每个允许存储 NULL 的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：

