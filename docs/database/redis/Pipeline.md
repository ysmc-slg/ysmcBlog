---
description: Pipeline
autoPrev: geoHash
---

# Pipeline(管道)

Redis是一种基于客户端-服务端模型以及请求/响应的TCP服务。一次Redis客户端发起的请求，经过服务端的响应后，大致会经历如下的步骤：

1. 客户端发起一个（查询/插入）请求，并监听socket返回，通常情况都是阻塞模式等待Redis服务器的响应
2. 服务端处理命令，并且返回处理结果给客户端
3. 客户端接收到服务的返回结果，程序从阻塞代码处返回
   
Redis客户端和服务端之间通过网络连接进行数据传输，这个连接可以很快（loopback接口）或很慢（建立了一个多次跳转的网络连接）。无论网络延如何延时，数据包总是能从客户端到达服务器，并从服务器返回数据回复客户端，这个时间被称之为RTT(Round Trip Time - 往返时间)。我们可以很容易就意识到，Redis在连续请求服务端时，即使Redis每秒能处理100k请求，但也会因为网络传输花费大量时间，导致整体性能的下降。
​

因此如果遇到大量的批处理，我们可以考虑使用Redis的pipeline（管道）。值得注意的是，管道技术并不是Redis特有的技术，管道技术往往需要客户端-服务器的共同配合，大部分工作任务其实是在客户端完成，很显然Redis支持管道技术，按照官网的意思，Redis的最低版本就考虑了管道技术的支持性设计。
​

如下图，多个连续的incr指令，使用pipeline（管道）后，多个连续的incr指令只会花费一次网络来回开销，这个开销会随着n数值的增大，大幅减少网络io开销，从而提升整体服务的性能。

![image-20230215231453570324](https://img-blog.csdnimg.cn/img_convert/4d5798ac4a99b037a8d5ea5eeb30f180.png)

## 原理

在上述简介中，提到了管道技术优化的是网络传输的耗时时间，这里通过Redis客户端-服务端的一次完整的网络请求来回，深入探索pipeline的本质。

![image-20230216104737400](https://img.zxqs.top/20230216104745.png)

1. 客户端调用write将数据写入操作系统内核(kernel)为socket连接分配的发送缓冲区(send buffer)
2. 客户端操作系统内核将发送缓冲区(send buffer)的数据发送到网卡(NIC)
3. 网卡(NIC)将数据通过路由(route)将数据送到Redis服务器机器网卡(NIC)
4. 服务器操作系统内核(kernel)将网卡(NIC)接收的数据，写入内核为socket分配的接收缓冲区(recv buffer)
5. 服务器进程从接收缓冲区调用read读取数据，并进行数据逻辑处理
6. 数据处理完成之后，服务器进程调用write将响应数据写入操作系统内核为socket分配的发送缓冲区
7. 操作系统内核将发送缓冲区的数据发送到服务器网卡
8. 服务器网卡将响应数据通过路由发送到客户端网卡
9. 客户端网卡接收响应数据
10. 客户端操作系统内核读取网卡接收到的服务器响应数据，并写入操作系统为socket连接分配的介绍缓冲区
11. 客户端进程调用read从接收缓冲区中读取服务器响应数据
12. 一次完整网络请求来回过程结束

**有个值得注意的点：**

在上述网络请求来回中，可能出现我们经常说到的io阻塞：

当write操作发生，并且发送缓冲区（send buffer）满时，就会导致write操作阻塞
当read操作发生，并且接收缓冲区（recv buffer）满时，就会导致read操作阻塞

上述的这两个阻塞如果出现，将会导致整个请求时间变长，因此我们操作大批量指令的时候，比如10k个指令，我们可以合理的对指令分多次批量发送，这样可以减少出现阻塞的情况，也可以避免服务器响应一个过大的答复包，导致客户端内存负载过重。