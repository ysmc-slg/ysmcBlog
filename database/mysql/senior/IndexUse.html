<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.27">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="icon" href="/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><meta name="theme-color" content="#ffffff"><meta name="google-site-verification" content=""><title>索引的使用 | 余生慢尝</title><meta name="description" content="余生慢尝, vuepress 文档">
    <link rel="modulepreload" href="/assets/app.e98ae9a9.js"><link rel="modulepreload" href="/assets/IndexUse.html.82e0838f.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.5a098b48.js"><link rel="modulepreload" href="/assets/IndexUse.html.bee5c739.js">
    <link rel="stylesheet" href="/assets/style.bde21de7.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container" data-v-3a25be96><!--[--><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name can-hide">余生慢尝</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/database/redis/" class="nav-link" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><li class="dropdown-item"><!--[--><h4 class="dropdown-subtitle"><a href="/database/mysql/" class="nav-link router-link-active" aria-label="Mysql"><!--[--><!--]--> Mysql <!--[--><!--]--></a></h4><ul class="dropdown-subitem-wrapper"><!--[--><li class="dropdown-subitem"><a href="/database/mysql/senior/" class="nav-link router-link-active" aria-label="高级部分"><!--[--><!--]--> 高级部分 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="java系"><span class="title">java系</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="java系"><span class="title">java系</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/java/basics/" class="nav-link" aria-label="java基础"><!--[--><!--]--> java基础 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/java/jdk8/" class="nav-link" aria-label="Java8新特性"><!--[--><!--]--> Java8新特性 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/java/reflection/" class="nav-link" aria-label="java反射"><!--[--><!--]--> java反射 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/java/json/" class="nav-link" aria-label="序列化"><!--[--><!--]--> 序列化 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="MQ"><span class="title">MQ</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="MQ"><span class="title">MQ</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/mq/rabbitmq/" class="nav-link" aria-label="rabbitMQ"><!--[--><!--]--> rabbitMQ <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="解决方案"><span class="title">解决方案</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="解决方案"><span class="title">解决方案</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/solution/dyanmicDataSource/" class="nav-link" aria-label="自定义动态数据源"><!--[--><!--]--> 自定义动态数据源 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/solution/log/" class="nav-link" aria-label="自定义日志注解"><!--[--><!--]--> 自定义日志注解 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/solution/asyncManager/" class="nav-link" aria-label="异步管理器"><!--[--><!--]--> 异步管理器 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/solution/excelAndUpload/" class="nav-link" aria-label="导入多出和上传下载"><!--[--><!--]--> 导入多出和上传下载 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="SSM"><span class="title">SSM</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="SSM"><span class="title">SSM</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/ssm/spring/" class="nav-link" aria-label="Spring"><!--[--><!--]--> Spring <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/ssm/springmvc/" class="nav-link" aria-label="SpringMVC"><!--[--><!--]--> SpringMVC <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/ssm/mybatis/" class="nav-link" aria-label="Mybatis"><!--[--><!--]--> Mybatis <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/ssm/integration/" class="nav-link" aria-label="SSM整合"><!--[--><!--]--> SSM整合 <!--[--><!--]--></a></li><li class="dropdown-item"><!--[--><h4 class="dropdown-subtitle"><span>高级部分</span></h4><ul class="dropdown-subitem-wrapper"><!--[--><li class="dropdown-subitem"><a href="/ssm/ssm-senior/spring/" class="nav-link" aria-label="Spring"><!--[--><!--]--> Spring <!--[--><!--]--></a></li><li class="dropdown-subitem"><a href="/ssm/ssm-senior/springmvc/" class="nav-link" aria-label="SpringMVC"><!--[--><!--]--> SpringMVC <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><a href="/springboot/" class="nav-link" aria-label="SpringBoot"><!--[--><!--]--> SpringBoot <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/springsecurity2/" class="nav-link" aria-label="SpringSecirity"><!--[--><!--]--> SpringSecirity <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="前端"><span class="title">前端</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="前端"><span class="title">前端</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/Front-end/es6/" class="nav-link" aria-label="ES6新特性"><!--[--><!--]--> ES6新特性 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/Front-end/vue/" class="nav-link" aria-label="VueJS"><!--[--><!--]--> VueJS <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="常用文档"><span class="title">常用文档</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="常用文档"><span class="title">常用文档</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a class="nav-link external" href="https://element.eleme.cn/#/zh-CN/component/table" rel="noopener noreferrer" target="_blank" aria-label="elementUI"><!--[--><!--]--> elementUI <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="dropdown-item"><a class="nav-link external" href="https://cn.vuejs.org/v2/guide/" rel="noopener noreferrer" target="_blank" aria-label="Vue文档"><!--[--><!--]--> Vue文档 <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="dropdown-item"><a class="nav-link external" href="http://momentjs.cn/docs/" rel="noopener noreferrer" target="_blank" aria-label="momentjs"><!--[--><!--]--> momentjs <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="dropdown-item"><a class="nav-link external" href="http://easypoi.mydoc.io/" rel="noopener noreferrer" target="_blank" aria-label="EasyPoi文档"><!--[--><!--]--> EasyPoi文档 <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="开发工具类"><span class="title">开发工具类</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="开发工具类"><span class="title">开发工具类</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/utils/stringutils/" class="nav-link" aria-label="StringUtils"><!--[--><!--]--> StringUtils <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><!--]--></nav><!--[--><!--[--><a class="icon-button" href="https://github.com/ysmc-slg/ysmcBlog" target="_blank" aria-label="View GitHub Repo" data-v-3a25be96><!----></a><!--]--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="首页"><!--[--><!--]--> 首页 <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="数据库"><span class="title">数据库</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/database/redis/" class="nav-link" aria-label="Redis"><!--[--><!--]--> Redis <!--[--><!--]--></a></li><li class="dropdown-item"><!--[--><h4 class="dropdown-subtitle"><a href="/database/mysql/" class="nav-link router-link-active" aria-label="Mysql"><!--[--><!--]--> Mysql <!--[--><!--]--></a></h4><ul class="dropdown-subitem-wrapper"><!--[--><li class="dropdown-subitem"><a href="/database/mysql/senior/" class="nav-link router-link-active" aria-label="高级部分"><!--[--><!--]--> 高级部分 <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="java系"><span class="title">java系</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="java系"><span class="title">java系</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/java/basics/" class="nav-link" aria-label="java基础"><!--[--><!--]--> java基础 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/java/jdk8/" class="nav-link" aria-label="Java8新特性"><!--[--><!--]--> Java8新特性 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/java/reflection/" class="nav-link" aria-label="java反射"><!--[--><!--]--> java反射 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/java/json/" class="nav-link" aria-label="序列化"><!--[--><!--]--> 序列化 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="MQ"><span class="title">MQ</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="MQ"><span class="title">MQ</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/mq/rabbitmq/" class="nav-link" aria-label="rabbitMQ"><!--[--><!--]--> rabbitMQ <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="解决方案"><span class="title">解决方案</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="解决方案"><span class="title">解决方案</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/solution/dyanmicDataSource/" class="nav-link" aria-label="自定义动态数据源"><!--[--><!--]--> 自定义动态数据源 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/solution/log/" class="nav-link" aria-label="自定义日志注解"><!--[--><!--]--> 自定义日志注解 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/solution/asyncManager/" class="nav-link" aria-label="异步管理器"><!--[--><!--]--> 异步管理器 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/solution/excelAndUpload/" class="nav-link" aria-label="导入多出和上传下载"><!--[--><!--]--> 导入多出和上传下载 <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="SSM"><span class="title">SSM</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="SSM"><span class="title">SSM</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/ssm/spring/" class="nav-link" aria-label="Spring"><!--[--><!--]--> Spring <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/ssm/springmvc/" class="nav-link" aria-label="SpringMVC"><!--[--><!--]--> SpringMVC <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/ssm/mybatis/" class="nav-link" aria-label="Mybatis"><!--[--><!--]--> Mybatis <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/ssm/integration/" class="nav-link" aria-label="SSM整合"><!--[--><!--]--> SSM整合 <!--[--><!--]--></a></li><li class="dropdown-item"><!--[--><h4 class="dropdown-subtitle"><span>高级部分</span></h4><ul class="dropdown-subitem-wrapper"><!--[--><li class="dropdown-subitem"><a href="/ssm/ssm-senior/spring/" class="nav-link" aria-label="Spring"><!--[--><!--]--> Spring <!--[--><!--]--></a></li><li class="dropdown-subitem"><a href="/ssm/ssm-senior/springmvc/" class="nav-link" aria-label="SpringMVC"><!--[--><!--]--> SpringMVC <!--[--><!--]--></a></li><!--]--></ul><!--]--></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><a href="/springboot/" class="nav-link" aria-label="SpringBoot"><!--[--><!--]--> SpringBoot <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/springsecurity2/" class="nav-link" aria-label="SpringSecirity"><!--[--><!--]--> SpringSecirity <!--[--><!--]--></a></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="前端"><span class="title">前端</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="前端"><span class="title">前端</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/Front-end/es6/" class="nav-link" aria-label="ES6新特性"><!--[--><!--]--> ES6新特性 <!--[--><!--]--></a></li><li class="dropdown-item"><a href="/Front-end/vue/" class="nav-link" aria-label="VueJS"><!--[--><!--]--> VueJS <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="常用文档"><span class="title">常用文档</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="常用文档"><span class="title">常用文档</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a class="nav-link external" href="https://element.eleme.cn/#/zh-CN/component/table" rel="noopener noreferrer" target="_blank" aria-label="elementUI"><!--[--><!--]--> elementUI <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="dropdown-item"><a class="nav-link external" href="https://cn.vuejs.org/v2/guide/" rel="noopener noreferrer" target="_blank" aria-label="Vue文档"><!--[--><!--]--> Vue文档 <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="dropdown-item"><a class="nav-link external" href="http://momentjs.cn/docs/" rel="noopener noreferrer" target="_blank" aria-label="momentjs"><!--[--><!--]--> momentjs <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><li class="dropdown-item"><a class="nav-link external" href="http://easypoi.mydoc.io/" rel="noopener noreferrer" target="_blank" aria-label="EasyPoi文档"><!--[--><!--]--> EasyPoi文档 <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><div class="navbar-links-item"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="开发工具类"><span class="title">开发工具类</span><span class="arrow down"></span></button><button class="mobile-dropdown-title" type="button" aria-label="开发工具类"><span class="title">开发工具类</span><span class="right arrow"></span></button><!--[--><ul style="display:none;" class="nav-dropdown"><!--[--><li class="dropdown-item"><a href="/utils/stringutils/" class="nav-link" aria-label="StringUtils"><!--[--><!--]--> StringUtils <!--[--><!--]--></a></li><!--]--></ul><!--]--></div></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--[--><p class="sidebar-heading sidebar-item active">MYSQL高级</p><ul class=""><li><!--[--><a href="/database/mysql/senior/role.html" class="nav-link sidebar-item" aria-label="用户与权限管理"><!--[--><!--]--> 用户与权限管理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/database/mysql/senior/logicStructure.html" class="nav-link sidebar-item" aria-label="逻辑架构"><!--[--><!--]--> 逻辑架构 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/database/mysql/senior/engines.html" class="nav-link sidebar-item" aria-label="存储引擎"><!--[--><!--]--> 存储引擎 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/database/mysql/senior/InnoDBRowFormat.html" class="nav-link sidebar-item" aria-label="InnoDB 行格式"><!--[--><!--]--> InnoDB 行格式 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/database/mysql/senior/dataPage.html" class="nav-link sidebar-item" aria-label="InnoDB 数据页结构"><!--[--><!--]--> InnoDB 数据页结构 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/database/mysql/senior/indexDataStructure.html" class="nav-link sidebar-item" aria-label="索引的数据结构"><!--[--><!--]--> 索引的数据结构 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/database/mysql/senior/" class="nav-link router-link-active sidebar-item" aria-label="索引的创建与设计原则"><!--[--><!--]--> 索引的创建与设计原则 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html" class="router-link-active router-link-exact-active nav-link router-link-active sidebar-item active" aria-label="索引的使用"><!--[--><!--]--> 索引的使用 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#索引的代价" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="索引的代价"><!--[--><!--]--> 索引的代价 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#索引适用的条件" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="索引适用的条件"><!--[--><!--]--> 索引适用的条件 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#全值匹配" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="全值匹配"><!--[--><!--]--> 全值匹配 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#匹配左边的列" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="匹配左边的列"><!--[--><!--]--> 匹配左边的列 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#匹配列前缀" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="匹配列前缀"><!--[--><!--]--> 匹配列前缀 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#匹配范围值" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="匹配范围值"><!--[--><!--]--> 匹配范围值 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#精确匹配某一列并范围匹配另外一列" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="精确匹配某一列并范围匹配另外一列"><!--[--><!--]--> 精确匹配某一列并范围匹配另外一列 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#用于排序" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="用于排序"><!--[--><!--]--> 用于排序 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#用于分组" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="用于分组"><!--[--><!--]--> 用于分组 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#回表的代价" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="回表的代价"><!--[--><!--]--> 回表的代价 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#覆盖索引" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="覆盖索引"><!--[--><!--]--> 覆盖索引 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#如何挑选索引" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="如何挑选索引"><!--[--><!--]--> 如何挑选索引 <!--[--><!--]--></a><ul class="sidebar-sub-items"><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#只为用于搜索、排序或分组的列创建索引" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="只为用于搜索、排序或分组的列创建索引"><!--[--><!--]--> 只为用于搜索、排序或分组的列创建索引 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#考虑列的基数" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="考虑列的基数"><!--[--><!--]--> 考虑列的基数 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#索引列的类型尽量小" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="索引列的类型尽量小"><!--[--><!--]--> 索引列的类型尽量小 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#索引字符串值的前缀" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="索引字符串值的前缀"><!--[--><!--]--> 索引字符串值的前缀 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#让索引列在比较表达式中单独出现" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="让索引列在比较表达式中单独出现"><!--[--><!--]--> 让索引列在比较表达式中单独出现 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#主键插入顺序" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="主键插入顺序"><!--[--><!--]--> 主键插入顺序 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#冗余和重复索引" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="冗余和重复索引"><!--[--><!--]--> 冗余和重复索引 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a aria-current="page" href="/database/mysql/senior/IndexUse.html#总结" class="router-link-active router-link-exact-active nav-link sidebar-item" aria-label="总结"><!--[--><!--]--> 总结 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--></li><li><!--[--><a href="/database/mysql/senior/dataDirectory.html" class="nav-link sidebar-item" aria-label="数据目录"><!--[--><!--]--> 数据目录 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/database/mysql/senior/singleTableAccess.html" class="nav-link sidebar-item" aria-label="单表访问方法"><!--[--><!--]--> 单表访问方法 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/database/mysql/senior/join.html" class="nav-link sidebar-item" aria-label="连接的原理"><!--[--><!--]--> 连接的原理 <!--[--><!--]--></a><!----><!--]--></li><li><!--[--><a href="/database/mysql/senior/transaction.html" class="nav-link sidebar-item" aria-label="MySQL 事务隔离级别"><!--[--><!--]--> MySQL 事务隔离级别 <!--[--><!--]--></a><!----><!--]--></li></ul><!--]--><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page" data-v-3a25be96><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="索引的使用" tabindex="-1"><a class="header-anchor" href="#索引的使用" aria-hidden="true">#</a> 索引的使用</h1><p>我们前面详细说了 InnoDB 存储引擎的 B+ 树索引，我们必须熟悉下边这些结论：</p><ul><li>每个索引都对应一颗 B+ 树，B+ 树分为好几层，最下边一层是叶子节点，其余是内节点。所有 <code>用户记录</code> 都存储在 B+ 树的叶子节点，所有 <code>目录项记录</code> 都存储在内节点。</li><li>InnoDB 存储引擎会自动为主键（如果没有它会自动帮我们添加）建立 <code>聚簇索引</code> ，聚簇索引的叶子节点包含完整的用户记录。</li><li>我们可以为自己感兴趣的列建立 <code>二级索引</code> ， <code>二级索引</code> 的叶子节点包含的用户记录由 <code>索引列 + 主键</code> 组成，所以如果想通过 <code>二级索引</code> 来查找完整的用户记录的话，需要通过 <code>回表</code> 操作，也就是在通过 <code>二级索引</code> 找到主键值之后再到 <code>聚簇索引</code> 中查找完整的用户记录。</li><li>B+ 树中每层节点都是按照索引列值从小到大的顺序排序而组成了双向链表，而且每个页内的记录（不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单链表。如果是 <code>联合索引</code> 的话，则页面和记录先按照 <code>联合索引</code> 前边的列排序，如果该列值相同，再按照 <code>联合索引</code> 后边的列排序。</li><li>通过索引查找记录是从 B+ 树的根节点开始，一层一层向下搜索。由于每个页面都按照索引列的值建立了 <code>Page Directory</code>（页目录），所以在这些页面中的查找非常快。</li></ul><h2 id="索引的代价" tabindex="-1"><a class="header-anchor" href="#索引的代价" aria-hidden="true">#</a> 索引的代价</h2><ul><li><p>空间上的代价：</p><p>这个是显而易见的，每建立一个索引都要为它建立一颗 B+ 树，每一科B+ 树的每一个节点都是一个数据页，一个页默认会占用 16KB 的存储空间，一棵很大的 B+ 树由许多数据页组成，那可是很大的一片存储空间呢。</p></li><li><p>时间上的代价：</p><p>每次对表中的数据进行增、删、改操作时，都需要去修改各个 B+ 树索引。而且我们讲过， B+ 树每层节点都是按照索引列的值从小到大的顺序排序而组成了双向链表。不论是叶子节点中的记录，还是内节点中的记录（也就是不论是用户记录还是目录项记录）都是按照索引列的值从小到大的顺序而形成了一个单向链表。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些记录移位，页面分裂、页面回收啥的操作来维护好节点和记录的排序。如果我们建了许多索引，每个索引对应的 B+ 树都要进行相关的维护操作，这还能不给性能拖后腿么？</p></li></ul><p>所以说，一个表上索引建的越多，就会占用越多的存储空间，在增删改记录的时候性能就越差。为了能建立又好又少的索引，我们先得学学这些索引在哪些条件下起作用的。</p><h2 id="索引适用的条件" tabindex="-1"><a class="header-anchor" href="#索引适用的条件" aria-hidden="true">#</a> 索引适用的条件</h2><p>B+ 树索引并不是万能的，并不是所有的查询语句都能用到我们建立的索引。下边介绍几个我们可能使用 B+ 树索引来进行查询的情况。我们需要先创建一个表，这个表是用来存储人的一些基本信息的：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> person_info<span class="token punctuation">(</span>
 id <span class="token keyword">INT</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>
 name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 birthday <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 phone_number <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 country <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token keyword">KEY</span> idx_name_birthday_phone_number <span class="token punctuation">(</span>name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>对于这个 person_info 表我们需要注意两点：</p><ul><li>表中的主键是 id 列，它存储一个自动递增的整数。所以 InnoDB 存储引擎会自动为 id 列建立聚簇索引。</li><li>我们额外定义了一个二级索引 idx_name_birthday_phone_number ，它是由3个列组成的联合索引。所以在这个索引对应的 B+ 树的叶子节点处存储的用户记录只保留 name 、 birthday 、 phone_number 这三个列的值以及主键 id 的值，并不会保存 country 列的值。</li></ul><p>从这两点注意中我们可以再次看到，一个表中有多少索引就会建立多少棵 B+ 树， <code>person_info</code> 表会为聚簇索引和 <code>idx_name_birthday_phone_number</code> 索引建立2棵 B+ 树。下边我们画一下索引<code>idx_name_birthday_phone_number</code> 的示意图，不过既然我们已经掌握了 InnoDB 的 B+ 树索引原理，那我们在画图的时候为了让图更加清晰，所以在省略一些不必要的部分，比如记录的额外信息，各页面的页号等等，其中内节点中目录项记录的页号信息我们用箭头来代替，在记录结构中只保留 name 、 birthday 、 phone_number 、id 这四个列的真实数据值，所以示意图就长这样：</p><p><img src="https://img.zxqs.top/20221229140425.png" alt="image-20221229140417402"></p><p>为了方便大家理解，我们特意标明了哪些是内节点，哪些是叶子节点。再次强调一下，内节点中存储的是 目录项记录 ，叶子节点中存储的是 用户记录 （由于不是聚簇索引，所以用户记录是不完整的，缺少 country 列的值）。从图中可以看出，这个 idx_name_birthday_phone_number 索引对应的 B+ 树中页面和记录的排序方式就是这样的：</p><ul><li>先按照 <code>name</code> 列的值进行排序</li><li>如果 <code>name</code> 列的值相同，则按照 <code>birthday</code> 列的值进行排序。</li><li>如果 <code>birthday</code> 的列也相同，则按照 <code>phone_number</code> 的值进行排序。</li></ul><p>因为 <code>页面和记录是排好序的</code>，我们就可以通过 <code>二分法</code> 来快速定位查找。</p><h3 id="全值匹配" tabindex="-1"><a class="header-anchor" href="#全值匹配" aria-hidden="true">#</a> 全值匹配</h3><p>如果我们的搜索条件中的列和索引列一致的话，这种情况就称为全值匹配，比方说下边这个查找语句：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span> <span class="token operator">AND</span> birthday <span class="token operator">=</span> <span class="token string">&#39;1990-09-27&#39;</span> <span class="token operator">AND</span> phone_number <span class="token operator">=</span> <span class="token string">&#39;15123983239&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>我们建立的 idx_name_birthday_phone_number 索引包含的3个列在这个查询语句中都展现出来了。大家可以想象一下这个查询过程：</p><ul><li>因为 B+ 树的数据页和记录先是按照 name 列的值进行排序的，所以先可以很快定位 name 列的值是 Ashburn的记录位置。</li><li>在 name 列相同的记录里又是按照 birthday 列的值进行排序的，所以在 name 列的值是 Ashburn 的记录里又可以快速定位 birthday 列的值是 &#39;1990-09-27&#39; 的记录。</li><li>如果很不幸， name 和 birthday 列的值都是相同的，那记录是按照 phone_number 列的值排序的，所以联合索引中的三个列都可能被用到。</li></ul><p>如果我们调换name 、 birthday 、 phone_number 这几个搜索列的顺序对查询的执行过程有影响么？比方说写成下边这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> birthday <span class="token operator">=</span> <span class="token string">&#39;1990-09-27&#39;</span> <span class="token operator">AND</span> phone_number <span class="token operator">=</span> <span class="token string">&#39;15123983239&#39;</span> A
ND name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>答案是：没影响哈。 MySQL 有一个叫查询优化器的东东，会分析这些搜索条件并且按照可以使用的索引中列的顺 序来决定先使用哪个搜索条件，后使用哪个搜索条件。我们后边儿会有专门的章节来介绍查询优化器。</p><h3 id="匹配左边的列" tabindex="-1"><a class="header-anchor" href="#匹配左边的列" aria-hidden="true">#</a> 匹配左边的列</h3><p>其实在我们的搜索语句中也可以不用包含全部联合索引中的列，只包含左边的就行，比方说下边的查询语句：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>或者包含多个左边的列也行：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span> <span class="token operator">AND</span> birthday <span class="token operator">=</span> <span class="token string">&#39;1990-09-27&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>那为什么搜索条件中必须出现左边的列才可以使用到这个 B+ 树索引呢？比如下边的语句就用不到这个 B+ 树索引么？</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> birthday <span class="token operator">=</span> <span class="token string">&#39;1990-09-27&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>是的，的确用不到，因为 B+ 树的数据页和记录先是按照 name 列的值排序的，在 name 列的值相同的情况下才使用 birthday 列进行排序，也就是说 name 列的值不同的记录中 birthday 的值可能是无序的。而现在你跳过name 列直接根据 birthday 的值去查找肯定不会使用索引。</p><p><code>如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</code>。比方说联合索引 idx_name_birthday_phone_number 中列的定义顺序是 name 、birthday 、 phone_number ，如果我们的搜索条件中只有 name 和 phone_number ，而没有中间的 birthday ，比方说这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span> <span class="token operator">AND</span> phone_number <span class="token operator">=</span> <span class="token string">&#39;15123983239&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>这样只能用到 name 列的索引， birthday 和 phone_number 的索引就用不上了，因为 name 值相同的记录先按照birthday 的值进行排序， birthday 值相同的记录才按照 phone_number 值进行排序。</p><h3 id="匹配列前缀" tabindex="-1"><a class="header-anchor" href="#匹配列前缀" aria-hidden="true">#</a> 匹配列前缀</h3><p>我们前边说过为某个列建立索引的意思其实就是在对应的 B+ 树的记录中使用该列的值进行排序，比方说person_info 表上建立的联合索引 idx_name_birthday_phone_number 会先用 name 列的值进行排序，所以这个联合索引对应的 B+ 树中的记录的 name 列的排列就是这样的：</p><div class="language-text ext-text"><pre class="language-text"><code>Aaron
Aaron
...
Aaron
Asa
Ashburn
...
Ashburn
Baird
Barlow
...
Barlow
</code></pre></div><p>字符串排序的本质就是比较哪个字符串大一点儿，哪个字符串小一点，比较字符串大小就用到了该列的字符集和比较规则，这个我们前边儿唠叨过，就不多唠叨了。这里需要注意的是，一般的比较规则都是逐个比较字符的大小，也就是说我们比较两个字符串的大小的过程其实是这样的：</p><ul><li>先比较字符串的第一个字符，第一个字符小的那个字符串就比较小。</li><li>如果两个字符串的第一个字符相同，那就再比较第二个字符，第二个字符比较小的那个字符串就比较小。</li><li>如果两个字符串的第二个字符也相同，那就接着比较第三个字符，依此类推。</li></ul><p>所以一个排好序的字符串列其实有这样的特点：</p><ul><li>先按照字符串的第一个字符进行排序。</li><li>如果第一个字符相同再按照第二个字符进行排序。</li><li>如果第二个字符相同再按照第三个字符进行排序，依此类推。</li></ul><p>也就是说这些字符串的前n个字符，也就是前缀都是排好序的，所以对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的，比方说我们想查询名字以 &#39;As&#39; 开头的记录，那就可以这么写查询语句：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">&#39;As%&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>但是需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">&#39;%As%&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>MySQL 就无法快速定位记录位置了，因为字符串中间有 &#39;As&#39; 的字符串并没有排好序，所以只能全表扫描了。有时候我们有一些匹配某些字符串后缀的需求，比方说某个表有一个 url 列，该列中存储了许多url：</p><p><img src="https://img.zxqs.top/20221229150923.png" alt="image-20221229150914422"></p><p>假设已经对该 url 列创建了索引，如果我们想查询以 com 为后缀的网址的话可以这样写查询条件： <code>WHERE url LIKE &#39;%com&#39;</code> ，但是这样的话无法使用该 url 列的索引。为了在查询时用到这个索引而不至于全表扫描，我们可以把后缀查询改写成前缀查询，不过我们就得把表中的数据全部逆序存储一下，也就是说我们可以这样保存 url 列中的数据：</p><p><img src="https://img.zxqs.top/20221229151019.png" alt="image-20221229151018750"></p><p>这样再查找以 com 为后缀的网址时搜索条件便可以这么写： <code>WHERE url LIKE &#39;moc%&#39;</code> ，这样就可以用到索引了。</p><h3 id="匹配范围值" tabindex="-1"><a class="header-anchor" href="#匹配范围值" aria-hidden="true">#</a> 匹配范围值</h3><p>回头看我们 <code>idx_name_birthday_phone_number</code> 索引的 B+ 树示意图，<code>所有记录都是按照索引列的值从小到大的顺序排好序的</code>，所以这极大的方便我们查找索引列的值在某个范围内的记录。比方说下边这个查询语句：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">&gt;</span> <span class="token string">&#39;Asa&#39;</span> <span class="token operator">AND</span> name <span class="token operator">&lt;</span> <span class="token string">&#39;Barlow&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>由于 B+ 树中的数据页和记录是先按 name 列排序的，所以我们上边的查询过程其实是这样的：</p><ul><li>找到 name 值为 Asa 的记录。</li><li>找到 name 值为 Barlow 的记录。</li><li>由于所有记录都是由链表连起来的（记录之间用单链表，数据页之间用双链表），所以他们之间的记录都可以很容易的取出来</li><li>找到这些记录的主键值，再到 <code>聚簇索引</code> 中 <code>回表</code> 查找完整的记录。</li></ul><p>不过在使用联合进行范围查找的时候需要注意，<code>如果对多个列同时进行范围查找的话，只有对索引最左边的那个 列进行范围查找的时候才能用到 B+ 树索引</code>，比方说这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">&gt;</span> <span class="token string">&#39;Asa&#39;</span> <span class="token operator">AND</span> name <span class="token operator">&lt;</span> <span class="token string">&#39;Barlow&#39;</span> <span class="token operator">AND</span> birthday <span class="token operator">&gt;</span> <span class="token string">&#39;1980-01-01&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>上边这个查询可以分成两个部分：</p><ol><li>通过条件 name &gt; &#39;Asa&#39; AND name &lt; &#39;Barlow&#39; 来对 name 进行范围，查找的结果可能有多条 name 值不同的记录</li><li>对这些 name 值不同的记录继续通过 birthday &gt; &#39;1980-01-01&#39; 条件继续过滤。</li></ol><p>这样子对于联合索引 <code>idx_name_birthday_phone_number</code> 来说，只能用到 <code>name</code> 列的部分，而用不到 <code>birthday</code> 列的部分，因为只有 <code>name</code> 值相同的情况下才能用 <code>birthday</code> 列的值进行排序，而这个查询中通过 name 进行范围查找的记录中可能并不是按照 birthday 列进行排序的，所以在搜索条件中继续以 birthday 列进行查找时是用不到这个 B+ 树索引的。</p><h3 id="精确匹配某一列并范围匹配另外一列" tabindex="-1"><a class="header-anchor" href="#精确匹配某一列并范围匹配另外一列" aria-hidden="true">#</a> 精确匹配某一列并范围匹配另外一列</h3><p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，比方说这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span> <span class="token operator">AND</span> birthday <span class="token operator">&gt;</span> <span class="token string">&#39;1980-01-01&#39;</span> <span class="token operator">AND</span> birthday <span class="token operator">&lt;</span> <span class="token string">&#39;2000-12-31&#39;</span> <span class="token operator">AND</span> phone_number <span class="token operator">&gt;</span> <span class="token string">&#39;15100000000&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>这个查询的条件可以分为3个部分：</p><ol><li>name = &#39;Ashburn&#39; ，对 name 列进行精确查找，当然可以使用 B+ 树索引了。</li><li>birthday &gt; &#39;1980-01-01&#39; AND birthday &lt; &#39;2000-12-31&#39; ，由于 name 列是精确查找，所以通过 name =&#39;Ashburn&#39; 条件查找后得到的结果的 name 值都是相同的，它们会再按照 birthday 的值进行排序。所以此时对 birthday 列进行范围查找是可以用到 B+ 树索引的。</li><li>phone_number &gt; &#39;15100000000&#39; ，通过 birthday 的范围查找的记录的 birthday 的值可能不同，所以这个条件无法再利用 B+ 树索引了，只能遍历上一步查询得到的记录。</li></ol><p>同理，下边的查询也是可能用到这个 idx_name_birthday_phone_number 联合索引的：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span> <span class="token operator">AND</span> birthday <span class="token operator">=</span> <span class="token string">&#39;1980-01-01&#39;</span> <span class="token operator">AND</span> <span class="token operator">AND</span> phone_number <span class="token operator">&gt;</span> <span class="token string">&#39;15100000000&#39;</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="用于排序" tabindex="-1"><a class="header-anchor" href="#用于排序" aria-hidden="true">#</a> 用于排序</h3><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>这个查询的结果集需要先按照 name 值排序，如果记录的 name 值相同，则需要按照 birthday 来排序，如果birthday 的值相同，则需要按照 phone_number 排序。大家可以回过头去看我们建立的idx_name_birthday_phone_number 索引的示意图，因为这个 B+ 树索引本身就是按照上述规则排好序的，所以直接从索引中提取数据，然后进行 回表 操作取出该索引中不包含的列就好了。</p><h4 id="使用联合索引进行排序注意事项" tabindex="-1"><a class="header-anchor" href="#使用联合索引进行排序注意事项" aria-hidden="true">#</a> 使用联合索引进行排序注意事项</h4><p>对于 <code>联合索引</code> 有个问题需要注意， <code>ORDER BY</code> 的子句后边的列的顺序也必须按照索引列的顺序给出，如果给出<code>ORDER BY phone_number, birthday, name</code> 的顺序，那也是用不了 B+ 树索引，这种颠倒顺序就不能使用索引的 原因我们上边详细说过了，这就不赘述了。</p><p>同理， <code>ORDER BY name</code> 、 <code>ORDER BY name, birthday</code> 这种匹配索引左边的列的形式可以使用部分的 B+ 树索引。当联合索引左边列的值为常量，也可以使用后边的列进行排序，比如这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> birthday<span class="token punctuation">,</span> phone_number <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>这个查询能使用联合索引进行排序是因为 name 列的值相同的记录是按照 birthday , phone_number 排序的。</p><h4 id="不可以使用索引进行排序的几种情况" tabindex="-1"><a class="header-anchor" href="#不可以使用索引进行排序的几种情况" aria-hidden="true">#</a> 不可以使用索引进行排序的几种情况</h4><p><strong>WHERE子句中出现非排序使用到的索引列：</strong></p><p>如果 <code>where</code> 子句中出现了非排序使用到的索引列，那么排序依然是使用不到索引的，比方说这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> country <span class="token operator">=</span> <span class="token string">&#39;China&#39;</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>这个查询只能先把符合搜索条件 country = &#39;China&#39; 的记录提取出来后再进行排序，是使用不到索引。注意和下边这个查询作区别：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;A&#39;</span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> birthday<span class="token punctuation">,</span> phone_number <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>虽然这个查询也有搜索条件，但是 name = &#39;A&#39; 可以使用到索引 idx_name_birthday_phone_number ，而且过滤剩下的记录还是按照 birthday 、 phone_number 列排序的，所以还是可以使用索引进行排序的。</p><p><strong>排序列包含非同一个索引的列：</strong></p><p>有时候用来排序的多个列不是一个索引里的，这种情况也不能使用索引进行排序，比方说：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name<span class="token punctuation">,</span> country <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>name 和 country 并不属于一个联合索引中的列，所以无法使用索引进行排序。</p><p><strong>排序列使用了复杂的表达式：</strong></p><p>要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式，比方说这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> UPPER<span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>使用了 UPPER 函数修饰过的列就不是单独的列啦，这样就无法使用索引进行排序啦。</p><h3 id="用于分组" tabindex="-1"><a class="header-anchor" href="#用于分组" aria-hidden="true">#</a> 用于分组</h3><p>有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number
</code></pre></div><p>这个查询语句相当于做了3次分组操作：</p><ol><li>先把记录按照 name 值进行分组，所有 name 值相同的记录划分为一组。</li><li>将每个 name 值相同的分组里的记录再按照 birthday 的值进行分组，将 birthday 值相同的记录放到一个小分组里，所以看起来就像在一个大分组里又化分了好多小分组。</li><li>再将上一步中产生的小分组按照 phone_number 的值分成更小的分组，所以整体上看起来就像是先把记录分成一个大分组，然后把 大分组 分成若干个 小分组 ，然后把若干个 小分组 再细分成更多的 小小分组 。</li></ol><p>然后针对那些 小小分组 进行统计，比如在我们这个查询语句中就是统计每个 小小分组 包含的记录条数。如果没有索引的话，这个分组过程全部需要在内存里实现，而如果有了索引的话，恰巧这个分组顺序又和我们的 B+ 树中的索引列的顺序是一致的，而我们的 B+ 树索引又是按照索引列排好序的，这不正好么，所以可以直接使用B+ 树索引进行分组。</p><p>和使用 B+ 树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组</p><h2 id="回表的代价" tabindex="-1"><a class="header-anchor" href="#回表的代价" aria-hidden="true">#</a> 回表的代价</h2><p>还是用 idx_name_birthday_phone_number 索引为例，看下边这个查询：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">&gt;</span> <span class="token string">&#39;Asa&#39;</span> <span class="token operator">AND</span> name <span class="token operator">&lt;</span> <span class="token string">&#39;Barlow&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>在使用 idx_name_birthday_phone_number 索引进行查询时大致可以分为这两个步骤：</p><ol><li>从索引 idx_name_birthday_phone_number 对应的 B+ 树中取出 name 值在 Asa ～ Barlow 之间的用户记录。</li><li>由于索引 idx_name_birthday_phone_number 对应的 B+ 树用户记录中只包含 name 、 birthday 、phone_number 、 id 这4个字段，而查询列表是 * ，意味着要查询表中所有字段，也就是还要包括 country字段。这时需要把从上一步中获取到的每一条记录的 id 字段都到聚簇索引对应的 B+ 树中找到完整的用户记录，也就是我们通常所说的 回表 ，然后把完整的用户记录返回给查询用户。</li></ol><p>由于索引 idx_name_birthday_phone_number 对应的 B+ 树中的记录首先会按照 name 列的值进行排序，所以值在 Asa ～ Barlow 之间的记录在磁盘中的存储是相连的，集中分布在一个或几个数据页中，我们可以很快的把这些连着的记录从磁盘中读出来，这种读取方式我们也可以称为 顺序I/O 。根据第1步中获取到的记录的 id 字段的值可能并不相连，而在聚簇索引中记录是根据 id （也就是主键）的顺序排列的，所以根据这些并不连续的 id值到聚簇索引中访问完整的用户记录可能分布在不同的数据页中，这样读取完整的用户记录可能要访问更多的数据页，这种读取方式我们也可以称为 随机I/O 。一般情况下，顺序I/O比随机I/O的性能高很多，所以步骤1的执行可能很快，而步骤2就慢一些。所以这个使用索引 idx_name_birthday_phone_number 的查询有这么两个特点：</p><ul><li>会使用到两个 B+ 树索引，一个二级索引，一个聚簇索引。</li><li>访问二级索引使用 顺序I/O ，访问聚簇索引使用 随机I/O 。</li></ul><p><code>需要回表的记录越多，使用二级索引的性能就越低</code>，甚至让某些查询宁愿使用全表扫描也不使用 <code>二级索引</code> 。比方说 name 值在 Asa ～ Barlow 之间的用户记录数量占全部记录数量90%以上，那么如果使用idx_name_birthday_phone_number 索引的话，有90%多的 id 值需要回表，这不是吃力不讨好么，还不如直接去扫描聚簇索引（也就是全表扫描）。</p><p>那什么时候采用全表扫描的方式，什么时候使用采用 二级索引 + 回表 的方式去执行查询呢？这个就是传说中的查询优化器做的工作，查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用 <code>二级索引 + 回表</code> 的方式。当然优化器做的分析工作不仅仅是这么简单，但是大致上是个这个过程。一般情况下，限制查询获取较少的记录数会让优化器更倾向于选择使用 <code>二级索引 + 回表</code> 的方式进行查询，因为回表的记录越少，性能提升就越高，比方说上边的查询可以改写成这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">&gt;</span> <span class="token string">&#39;Asa&#39;</span> <span class="token operator">AND</span> name <span class="token operator">&lt;</span> <span class="token string">&#39;Barlow&#39;</span> <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>添加了 LIMIT 10 的查询更容易让优化器采用 <code>二级索引 + 回表</code> 的方式进行查询。</p><p>对于有排序需求的查询，上边讨论的采用 <code>全表扫描</code> 还是 <code>二级索引 + 回表</code> 的方式进行查询的条件也是成立的， 比方说下边这个查询：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number<span class="token punctuation">;</span>
</code></pre></div><p>由于查询列表是 <code>*</code> ，所以如果使用二级索引进行排序的话，需要把排序完的二级索引记录全部进行回表操作，这样操作的成本还不如直接遍历聚簇索引然后再进行文件排序（ filesort ）低，所以优化器会倾向于使用 全表扫描 的方式执行查询。如果我们加了 LIMIT 子句，比如这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>这样需要回表的记录特别少，优化器就会倾向于使用 <code>二级索引 + 回表</code> 的方式执行查询。</p><h3 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引</h3><p>为了彻底告别 回表 操作带来的性能损耗，我们建议：<code>最好在查询列表里只包含索引列</code>，比如这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number <span class="token keyword">FROM</span> person_info <span class="token keyword">WHERE</span> name <span class="token operator">&gt;</span> <span class="token string">&#39;Asa&#39;</span> <span class="token operator">AND</span> name <span class="token operator">&lt;</span> <span class="token string">&#39;Barlow&#39;</span>
</code></pre></div><p>因为我们只查询 name , birthday , phone_number 这三个索引列的值，所以在通过<code>idx_name_birthday_phone_number</code> 索引得到结果后就不必到 <code>聚簇索引</code> 中再查找记录的剩余列，也就是<code>country</code> 列的值了，这样就省去了 <code>回表</code> 操作带来的性能损耗。我们把这种只需要用到索引的查询方式称为 <code>索引覆盖</code> 。排序操作也优先使用 覆盖索引 的方式进行查询，比方说这个查询：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number <span class="token keyword">FROM</span> person_info <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number<span class="token punctuation">;</span>
</code></pre></div><p>虽然这个查询中没有 <code>LIMIT</code> 子句，但是采用了 <code>覆盖索引</code> ，所以查询优化器就会直接使用<code>idx_name_birthday_phone_number</code> 索引进行排序而不需要回表操作了。</p><p>当然，如果业务需要查询出索引以外的列，那还是以保证业务需求为重。<code>但是我们很不鼓励用 * 号作为查询列表，最好把我们需要查询的列依次标明</code>。</p><h2 id="如何挑选索引" tabindex="-1"><a class="header-anchor" href="#如何挑选索引" aria-hidden="true">#</a> 如何挑选索引</h2><p>上边我们以 <code>idx_name_birthday_phone_numbe</code>r 索引为例对索引的适用条件进行了详细的说明，下边看一下我们 在建立索引时或者编写查询语句时就应该注意的一些事项。</p><h3 id="只为用于搜索、排序或分组的列创建索引" tabindex="-1"><a class="header-anchor" href="#只为用于搜索、排序或分组的列创建索引" aria-hidden="true">#</a> 只为用于搜索、排序或分组的列创建索引</h3><p>也就是说，只为出现在 WHERE 子句中的列、连接子句中的连接列，或者出现在 ORDER BY 或 GROUP BY 子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> birthday<span class="token punctuation">,</span> country <span class="token keyword">FROM</span> person name <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Ashburn&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>像查询列表中的 birthday 、 country 这两个列就不需要建立索引，我们只需要为出现在 WHERE 子句中的 name列创建索引就可以了。</p><h3 id="考虑列的基数" tabindex="-1"><a class="header-anchor" href="#考虑列的基数" aria-hidden="true">#</a> 考虑列的基数</h3><p><code>列的基数</code> 指的是某一列中不重复数据的个数，比方说某个列包含值 2, 5, 8, 2, 5, 8, 2, 5, 8 ，虽然有 9 条记录，但该列的基数却是 3 。也就是说，<code>在记录行数一定的情况下，列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中</code>。这个 <code>列的基数</code> 指标非常重要，直接影响我们是否能有效的利用索引。假设某个列的基数为 1 ，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为所有值都一样就无法排序，无法进行快速查找了～ 而且如果某个建立了二级索引的列的重复值特别多，那么使用这个二级索引查出的记录还可能要做回表操作，这样性能损耗就更大了。所以结论就是：<code>最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好</code>。</p><h3 id="索引列的类型尽量小" tabindex="-1"><a class="header-anchor" href="#索引列的类型尽量小" aria-hidden="true">#</a> 索引列的类型尽量小</h3><p>我们在定义表结构的时候要显式的指定列的类型，以整数类型为例，有 TINYINT 、 MEDIUMINT 、 INT 、 BIGINT这么几种，它们占用的存储空间依次递增，我们这里所说的 类型大小 指的就是<code>该类型表示的数据范围的大小</code>。能表示的整数范围当然也是依次递增，如果我们想要对某个整数列建立索引的话，<code>在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</code>，比如我们能使用 INT 就不要使用 BIGINT ，能使用 MEDIUMINT 就不要使用INT ～ 这是因为：</p><ul><li>数据类型越小，在查询时进行的比较操作越快</li><li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘 I/O 带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ul><p>这个建议对于表的主键来说更加适用，因为不仅是聚簇索引中会存储主键值，其他所有的二级索引的节点处都会存储一份记录的主键值，如果主键适用更小的数据类型，也就意味着节省更多的存储空间和更高效的 I/O 。</p><h3 id="索引字符串值的前缀" tabindex="-1"><a class="header-anchor" href="#索引字符串值的前缀" aria-hidden="true">#</a> 索引字符串值的前缀</h3><p>我们知道一个字符串其实是由若干个字符组成，如果我们在 MySQL 中使用 utf8 字符集去存储字符串的话，编码一个字符需要占用 1~3 个字节。假设我们的字符串很长，那存储一个字符串就需要占用很大的存储空间。在我们需要为这个字符串列建立索引时，那就意味着在对应的 B+ 树中有这么两个问题：</p><ul><li>B+ 树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。</li><li>如果 B+ 树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。</li></ul><p>我们前边儿说过索引列的字符串前缀其实也是排好序的，所以索引的设计者提出了个方案 --- <code>只对字符串的前几个字符进行索引</code>也就是说在二级索引的记录中只保留字符串前几个字符。这样在查找记录时虽然不能精确的定位到记录的位置，但是能定位到相应前缀所在的位置，然后根据前缀相同的记录的主键值回表查询完整的字符串值，再对比就好了。这样只在 B+ 树中存储字符串的前几个字符的编码，既节约空间，又减少了字符串的比较时间，还大概能解决排序的问题，何乐而不为，比方说我们在建表语句中只对 name 列的前10个字符进行索引可以这么写：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> person_info<span class="token punctuation">(</span>
 name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 birthday <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 phone_number <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 country <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token keyword">KEY</span> idx_name_birthday_phone_number <span class="token punctuation">(</span>name<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>name(10) 就表示在建立的 B+ 树索引中只保留记录的前 10 个字符的编码，<code>这种只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候</code>。</p><h4 id="索引列前缀对排序的影响" tabindex="-1"><a class="header-anchor" href="#索引列前缀对排序的影响" aria-hidden="true">#</a> 索引列前缀对排序的影响</h4><p>如果使用了索引列前缀，比方说前边只把 name 列的前10个字符放到了二级索引中，下边这个查询可能就有点儿尴尬了：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> person_info <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> name <span class="token keyword">LIMIT</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre></div><p>因为二级索引中不包含完整的 name 列信息，所以无法对前十个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序，只能用文件排序。</p><h3 id="让索引列在比较表达式中单独出现" tabindex="-1"><a class="header-anchor" href="#让索引列在比较表达式中单独出现" aria-hidden="true">#</a> 让索引列在比较表达式中单独出现</h3><p>假设表中有一个整数列 my_col ，我们为这个列建立了索引。下边的两个 WHERE 子句虽然语义是一致的，但是在效率上却有差别：</p><ol><li>WHERE my_col * 2 &lt; 4</li><li>WHERE my_col &lt; 4/2</li></ol><p>第1个 WHERE 子句中 my_col 列并不是以单独列的形式出现的，而是以 my_col * 2 这样的表达式的形式出现的，存储引擎<code>会依次遍历所有的记录，计算这个表达式的值是不是小于 4</code> ，所以这种情况下是使用不到为 my_col 列建立的 B+ 树索引的。而第2个 WHERE 子句中 my_col 列并是以单独列的形式出现的，这样的情况可以直接使用B+ 树索引。</p><p>所以结论就是：<code>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的</code>。</p><h3 id="主键插入顺序" tabindex="-1"><a class="header-anchor" href="#主键插入顺序" aria-hidden="true">#</a> 主键插入顺序</h3><p>我们知道，对于一个使用 InnoDB 存储引擎的表来说，在我们没有显式的创建索引时，表中的数据实际上都是存储在 聚簇索引 的叶子节点的。而记录又是存储在数据页中的，数据页和记录又是按照记录主键值从小到大的顺序进行排序，所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插，而如果我们插入的主键值忽大忽小的话，这就比较麻烦了，假设某个数据页存储的记录已经满了，它存储的主键值在 1~100 之间：</p><p><img src="https://img.zxqs.top/20221229182053.png" alt="image-20221229182052704"></p><p>如果此时再插入一条主键值为 9 的记录，那它插入的位置就如下图：</p><p><img src="https://img.zxqs.top/20221229182121.png" alt="image-20221229182119837"></p><p>可这个数据页已经满了啊，再插进来咋办呢？我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？意味着：<code>性能损耗</code>！所以如果我们想尽量避免这样无谓的性能损耗，最好让插入的记录的主键值依次递增，这样就不会发生这样的性能损耗了。所以我们建议：<code>让主键具有 AUTO_INCREMENT ，让存储引擎自己为表生成主键，而不是我们手动插入</code>，比方说我们可以这样定义person_info 表：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> person_info<span class="token punctuation">(</span>
 id <span class="token keyword">INT</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
 name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 birthday <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 phone_number <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 country <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token keyword">KEY</span> idx_name_birthday_phone_number <span class="token punctuation">(</span>name<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们自定义的主键列 id 拥有 AUTO_INCREMENT 属性，在插入记录时存储引擎会自动为我们填入自增的主键值。</p><h3 id="冗余和重复索引" tabindex="-1"><a class="header-anchor" href="#冗余和重复索引" aria-hidden="true">#</a> 冗余和重复索引</h3><p>有时候有的同学有意或者无意的就对同一个列创建了多个索引，比方说这样写建表语句：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> person_info<span class="token punctuation">(</span>
 id <span class="token keyword">INT</span> <span class="token keyword">UNSIGNED</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
 name <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 birthday <span class="token keyword">DATE</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 phone_number <span class="token keyword">CHAR</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 country <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
 <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token keyword">KEY</span> idx_name_birthday_phone_number <span class="token punctuation">(</span>name<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> phone_number<span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token keyword">KEY</span> idx_name <span class="token punctuation">(</span>name<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们知道，通过 idx_name_birthday_phone_number 索引就可以对 name 列进行快速搜索，再创建一个专门针对name 列的索引就算是一个 冗余 索引，维护这个索引只会增加维护的成本，并不会对搜索有什么好处。</p><p>另一种情况，我们可能会对某个列重复建立索引，比方说这样：</p><div class="language-sql ext-sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> repeat_index_demo <span class="token punctuation">(</span>
 c1 <span class="token keyword">INT</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">,</span>
 c2 <span class="token keyword">INT</span><span class="token punctuation">,</span>
 <span class="token keyword">UNIQUE</span> uidx_c1 <span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token keyword">INDEX</span> idx_c1 <span class="token punctuation">(</span>c1<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们看到， c1 既是主键、又给它定义为一个唯一索引，还给它定义了一个普通索引，可是主键本身就会生成聚簇索引，所以定义的唯一索引和普通索引是重复的，这种情况要避免。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>上边只是我们在创建和使用 B+ 树索引的过程中需要注意的一些点，后边我们还会陆续介绍更多的优化方法和注 意事项，敬请期待。本集内容总结如下：</p><ol><li>B+ 树索引在空间和时间上都有代价，所以没事儿别瞎建索引。</li><li>B+ 树索引适用于下边这些情况： <ul><li>全值匹配</li><li>匹配左边的列</li><li>匹配范围值</li><li>精确匹配某一列并范围匹配另外一列</li><li>用于排序</li><li>用于分组</li></ul></li><li>在使用索引时需要注意下边这些事项： <ul><li>只为用于搜索、排序或分组的列创建索引</li><li>为列的基数大的列创建索引</li><li>索引列的类型尽量小</li><li>可以只对字符串值的前缀建立索引</li><li>只有索引列在比较表达式中单独出现才可以适用索引</li><li>为了尽可能少的让 聚簇索引 发生页面分裂和记录移位的情况，建议让主键拥有 AUTO_INCREMENT 属性。</li><li>定位并删除表中的重复和冗余索引</li><li>尽量使用 <code>覆盖索引</code> 进行查询，避免 <code>回表</code> 带来的性能损耗</li></ul></li></ol><!--]--></div><footer class="page-meta"><div class="meta-item edit-link"><a class="nav-link external meta-item-label" href="https://github.com/ysmc-slg/ysmcBlog/edit/master/docs/database/mysql/senior/IndexUse.md" rel="noopener noreferrer" target="_blank" aria-label="编辑文档！"><!--[--><!--]--> 编辑文档！ <span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span><!--[--><!--]--></a></div><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><span class="meta-item-info">2023/1/11 16:23:55</span></div><div class="meta-item contributors"><span class="meta-item-label">贡献者: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 494786209@qq.com">ysmc</span><!----><!--]--><!--]--></span></div></footer><nav class="page-nav"><p class="inner"><span class="prev"> ← <a href="/database/mysql/senior/" class="nav-link router-link-active" aria-label="索引的创建与设计原则"><!--[--><!--]--> 索引的创建与设计原则 <!--[--><!--]--></a></span><span class="next"><a href="/database/mysql/senior/dataDirectory.html" class="nav-link" aria-label="数据目录"><!--[--><!--]--> 数据目录 <!--[--><!--]--></a> → </span></p></nav><!--[--><!--]--></main><!--]--></div><!----><!----><!--]--></div>
    <script type="module" src="/assets/app.e98ae9a9.js" defer></script>
  </body>
</html>
