(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{464:function(s,t,v){"use strict";v.r(t);var r=v(32),a=Object(r.a)({},(function(){var s=this,t=s.$createElement,v=s._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("p",[s._v("Redis 提供了2个不同形式的持久化方式。")]),s._v(" "),v("ul",[v("li",[s._v("RDB（Redis DataBase）")]),s._v(" "),v("li",[s._v("AOF（Append Of File）")])]),s._v(" "),v("h2",{attrs:{id:"简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[s._v("#")]),s._v(" 简介")]),s._v(" "),v("p",[s._v("在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是Snapshot快照，它恢复时将快照文件直接读到内存里。")]),s._v(" "),v("p",[v("font",{attrs:{color:"red"}},[s._v("Redis会单独创建（Fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。")]),s._v(" 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。")],1),s._v(" "),v("p",[v("code",[s._v("Fork")]),s._v("的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量‘程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。")]),s._v(" "),v("p",[v("code",[s._v("rdb模式默认是开启的")])]),s._v(" "),v("h2",{attrs:{id:"rdb相关的配置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rdb相关的配置"}},[s._v("#")]),s._v(" RDB相关的配置")]),s._v(" "),v("p",[s._v("快照临时文件的保存位置，默认在哪个路径下启动的redis，临时文件就在哪，同时文件名默认为"),v("code",[s._v("dump.rdb")]),s._v("。也可以修改文件路径和文件名")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blogImg/redis/20210602125649.png",alt:"dump"}})]),s._v(" "),v("h3",{attrs:{id:"save"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#save"}},[s._v("#")]),s._v(" save")]),s._v(" "),v("p",[v("img",{attrs:{src:"/blogImg/redis/20210602132132.png",alt:"dump2"}})]),s._v(" "),v("p",[s._v("默认触发时间，分别表示 3600 秒（60 分钟）内有 1 个更改，300 秒（5 分钟）内有 100 个更改以及 60 秒内有 10000 个更改，当有一个条件满足就会触发快照。")]),s._v(" "),v("p",[s._v("如果想禁用RDB持久化策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以。")]),s._v(" "),v("h3",{attrs:{id:"stop-writes-on-bgsave-error"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#stop-writes-on-bgsave-error"}},[s._v("#")]),s._v(" Stop-writes-on-bgsave-error")]),s._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),v("p",[s._v("默认是yes，如果配置成no，表示不在乎数据不一致或者有其他的手段发现和控制。")])]),s._v(" "),v("h3",{attrs:{id:"rdbcompression"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rdbcompression"}},[s._v("#")]),s._v(" rdbcompression")]),s._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),v("p",[s._v("默认是yes")]),s._v(" "),v("p",[s._v("rdbcompression：对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，redis会采用LZF算法进行压缩。如果不想消耗CPU来进行压缩的话，可以设置为no关闭此功能。")])]),s._v(" "),v("h3",{attrs:{id:"rdbchecksum"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rdbchecksum"}},[s._v("#")]),s._v(" rdbchecksum")]),s._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),v("p",[s._v("默认是yes")]),s._v(" "),v("p",[s._v("rdbchecksum：在存储快照后，还可以让redis使用CRC64算法来进行数据校验，但是这样做会增大大约10%的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。")])]),s._v(" "),v("h2",{attrs:{id:"如何触发rdb快照"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何触发rdb快照"}},[s._v("#")]),s._v(" 如何触发RDB快照")]),s._v(" "),v("ul",[v("li",[v("p",[s._v("配置文件中默认的快照配置，当满足快照触发的时间和操作次数。就会触发快照。其实也是执行"),v("code",[s._v("bgsave")]),s._v("只不过是服务器自动执行")])]),s._v(" "),v("li",[v("p",[s._v("如果想马上触发快照，使用"),v("code",[s._v("save")]),s._v("或"),v("code",[s._v("bgsave")]),s._v("，save时只管保存，其他不管，全部阻塞，直到RDB文件创建完毕为止，在整个RDB文件生成过程中服务器不能处理任何命令请求。bgsave时Redis会在后台异步进行快照操作，快照操作同时还可以响应客户端请求。可以通过lastsave命令获取最后一次成功执行快照的时间。")])]),s._v(" "),v("li",[v("p",[s._v("执行"),v("code",[s._v("flushall")]),s._v("命令也会触发快照，先清空内存，然后再快照。所以生成的"),v("code",[s._v("dump.rdb")]),s._v("文件是空的。")])])]),s._v(" "),v("p",[v("img",{attrs:{src:"/blogImg/redis/20210602143238.png",alt:"rdb"}})]),s._v(" "),v("h2",{attrs:{id:"恢复数据"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#恢复数据"}},[s._v("#")]),s._v(" 恢复数据")]),s._v(" "),v("p",[s._v("redis启动默认会将"),v("code",[s._v("dump.rdb")]),s._v("文件读到内存中，所以只要保证"),v("code",[s._v("dump.rdb")]),s._v("数据就可以了")]),s._v(" "),v("h2",{attrs:{id:"优势和劣势"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优势和劣势"}},[s._v("#")]),s._v(" 优势和劣势")]),s._v(" "),v("p",[v("strong",[s._v("优势")]),s._v("：")]),s._v(" "),v("ul",[v("li",[s._v("适合大规模的数据恢复")]),s._v(" "),v("li",[s._v("对数据完整性和一致性要求不高")])]),s._v(" "),v("p",[v("strong",[s._v("劣势")]),s._v("：")]),s._v(" "),v("ul",[v("li",[s._v("在一定间隔时间做一次快照，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。")]),s._v(" "),v("li",[s._v("Fork的时候，内存中的数据被克隆了一份，大约2倍的膨胀性需要考虑。")])])])}),[],!1,null,null,null);t.default=a.exports}}]);