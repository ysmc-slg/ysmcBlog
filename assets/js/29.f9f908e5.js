(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{458:function(e,s,t){"use strict";t.r(s);var n=t(32),a=Object(n.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"简介"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[e._v("#")]),e._v(" 简介")]),e._v(" "),t("p",[e._v("Sentinel(哨兵)是用于"),t("code",[e._v("监控redis集群中Master状态")]),e._v("的工具，是Redis 的高可用性解决方案，sentinel哨兵模式已经被集成在redis2.4之后的版本中。sentinel是redis高可用的解决方案，"),t("code",[e._v("sentinel系统可以监视一个或者多个redis master服务，以及这些master服务的所有从服务；当某个master服务下线时，自动将该master下的某个从服务升级为master服务替代已下线的master服务继续处理请求。")])]),e._v(" "),t("p",[e._v("sentinel可以让redis实现主从复制，当一个集群中的master失效之后，sentinel可以选举出一个新的master用于自动接替master的工作，集群中的其他redis服务器自动指向新的master同步数据。一般建议sentinel采取奇数台，防止某一台sentinel无法连接到master导致误切换。其结构如下:")]),e._v(" "),t("p",[t("img",{attrs:{src:"/blogImg/redis/20210617132409.png",alt:"sentinel"}})]),e._v(" "),t("p",[t("strong",[e._v("Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案")]),e._v("，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。Sentinel由一个或多个Sentinel 实例 组成的Sentinel 系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。")]),e._v(" "),t("p",[e._v("例如下图所示：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/blogImg/redis/20210617132746.png",alt:"sentinel2"}})]),e._v(" "),t("p",[e._v("在Server1 掉线后：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/blogImg/redis/20210617133013.png",alt:"sentinel2"}})]),e._v(" "),t("p",[e._v("升级Server2 为新的主服务器：")]),e._v(" "),t("p",[t("img",{attrs:{src:"/blogImg/redis/20210617133044.png",alt:"sentinel3"}})]),e._v(" "),t("h2",{attrs:{id:"sentinel的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sentinel的作用"}},[e._v("#")]),e._v(" Sentinel的作用")]),e._v(" "),t("ul",[t("li",[e._v("通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。")]),e._v(" "),t("li",[e._v("当哨兵监测到master宕机，会自动将slave切换成master，然后通过"),t("code",[e._v("发布订阅模式")]),e._v("通知其他的从服务器，修改配置文件，让它们切换主机。")])]),e._v(" "),t("h2",{attrs:{id:"sentinel的工作方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sentinel的工作方式"}},[e._v("#")]),e._v(" Sentinel的工作方式")]),e._v(" "),t("ol",[t("li",[e._v("每个Sentinel以"),t("code",[e._v("每10秒钟一次")]),e._v("的频率向它所知的Master，Slave以及其他 Sentinel 实例发送一个PING命令。")]),e._v(" "),t("li",[e._v("如果一个实例（instance）距离最后一次有效回复PING命令的时间超过 down-after-milliseconds 选项所指定的值，则这个实例会被Sentinel标记为"),t("code",[e._v("主观下线")]),e._v("。")]),e._v(" "),t("li",[e._v("如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。")]),e._v(" "),t("li",[e._v("当有足够数量的Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态，则Master会被标记为"),t("code",[e._v("客观下线")]),e._v("。")]),e._v(" "),t("li",[e._v("在一般情况下，每个Sentinel 会以每10秒一次的频率向它已知的所有Master，Slave发送 INFO 命令。")]),e._v(" "),t("li",[e._v("当Master被Sentinel标记为客观下线时，Sentinel 向下线的 Master 的所有Slave发送 INFO命令的频率会从10秒一次改为每秒一次。")]),e._v(" "),t("li",[e._v("若没有足够数量的Sentinel同意Master已经下线，Master的客观下线状态就会被移除。 若 Master重新向Sentinel 的PING命令返回有效回复，Master的主观下线状态就会被移除。")])]),e._v(" "),t("h2",{attrs:{id:"sentinel-conf"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sentinel-conf"}},[e._v("#")]),e._v(" sentinel.conf")]),e._v(" "),t("ol",[t("li",[t("p",[t("code",[e._v("sentinel monitor <masterName> <ip> <port> <quorum>")])]),e._v(" "),t("ul",[t("li",[e._v("masterName：对某个master+slave组合的一个区分标识（一套sentinel是可以监听多套master+slave这样的组合的）")]),e._v(" "),t("li",[e._v("ip 和 port 就是master节点的 ip 和 端口号。")]),e._v(" "),t("li",[e._v("quorum："),t("code",[e._v("客观下线的一个依据")]),e._v("，意思是至少有 quorum 个sentinel标记这个master为"),t("code",[e._v("主观下线")]),e._v("，才会对这个master进行下线以及故障转移。quorum的值一般设置为sentinel个数的二分之一加1，例如3个sentinel就设置2。")])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("sentinel down-after-milliseconds <masterName> <timeout>")])])])]),e._v(" "),t("p",[e._v("这个配置其实就是进行"),t("code",[e._v("主观下线的一个依据")]),e._v("，masterName和上面的一样，timeout是一个毫秒值，表示：如果这台sentinel超过timeout这个时间都无法连通master包括slave（slave不需要客观下线，因为不需要故障转移）的话，就会主观认为该master已经下线（实际下线需要客观下线的判断通过才会下线）")]),e._v(" "),t("h2",{attrs:{id:"使用哨兵模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用哨兵模式"}},[e._v("#")]),e._v(" 使用哨兵模式")]),e._v(" "),t("p",[e._v("首先创建一个"),t("code",[e._v("sentinel.conf")]),e._v("文件，文件名一定不能错。同时添加以下配置")]),e._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[e._v("sentinel monitor "),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("masterName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(" "),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("ip"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(" "),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("port"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(" "),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("quorum"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\nsentinel auth"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("pass "),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("masterName"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(" "),t("span",{pre:!0,attrs:{class:"token generics"}},[t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),e._v("password"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v("\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br")])]),t("p",[e._v("如果你的redis没有设置密码，第二条配置不写")]),e._v(" "),t("p",[t("img",{attrs:{src:"/blogImg/redis/20210617152207.png",alt:"sentinel3"}})]),e._v(" "),t("p",[e._v("然后使用 "),t("code",[e._v("redis-sentinel /sentinel.conf")]),e._v(" ，启动哨兵模式")]),e._v(" "),t("p",[t("img",{attrs:{src:"/blogImg/redis/20210617152307.png",alt:"sentinel3"}})]),e._v(" "),t("p",[e._v("此时哨兵就已经启动了，如果master挂了，会自动切换从服务为master")]),e._v(" "),t("p",[t("img",{attrs:{src:"/blogImg/redis/20210617160013.png",alt:"sentinel3"}})]),e._v(" "),t("p",[e._v("可以看到6381代替了6379，成为了master，如果6379重新启动只能当做slave")]),e._v(" "),t("p",[t("img",{attrs:{src:"/blogImg/redis/20210617160331.png",alt:"sentinel3"}})]),e._v(" "),t("h2",{attrs:{id:"主观下线"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主观下线"}},[e._v("#")]),e._v(" 主观下线")]),e._v(" "),t("p",[e._v("sentinel会向所有与其建立了命令连接的实例（master，slave，其他sentinel）发ping命令，如果在"),t("code",[e._v("down-after-milliseconds")]),e._v("给定的毫秒数之内，没有回复， 或者返回一个错误， 那么 Sentinel 将这个服务器标记为主观下线（sdown）。")]),e._v(" "),t("h2",{attrs:{id:"客观下线"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#客观下线"}},[e._v("#")]),e._v(" 客观下线")]),e._v(" "),t("p",[e._v("客观下线（odown）指的是多个 Sentinel 实例在对同一个"),t("code",[e._v("master")]),e._v("做出"),t("code",[e._v("主观下线 (sdown)")]),e._v("判断， 并且通过 "),t("code",[e._v("SENTINEL is-master-down-by-addr")]),e._v(" 命令互相交流之后， 有足够的Sentinel（可以设置） 都将"),t("code",[e._v("master")]),e._v("标记为"),t("code",[e._v("主观下线")]),e._v("之后，"),t("code",[e._v("master")]),e._v("才会被标记为"),t("code",[e._v("客观下线")]),e._v("，然后开启"),t("code",[e._v("故障转移(failover)")]),e._v("。")]),e._v(" "),t("p",[t("strong",[e._v("详解：")])]),e._v(" "),t("p",[e._v("sentinel通过发送"),t("code",[e._v("SENTINEL is-master-down-by-addr <ip> <port> <current_epoch> <runid>")]),e._v("命令，来询问其它sentinel是否同意服务下线。")]),e._v(" "),t("ul",[t("li",[e._v("ip：被Sentinel判断为主观下线的主服务器的IP地址")]),e._v(" "),t("li",[e._v("port：被Sentinel判断为主观下线的主服务器的端口号")]),e._v(" "),t("li",[e._v("current_epoch：Sentinel当前的配置纪元，用于选举领头Sentinel")]),e._v(" "),t("li",[e._v("runid："),t("code",[e._v("*")]),e._v("表示检测服务下线状态，如果是sentinel 运行id，表示用来选举领头sentinel")])]),e._v(" "),t("p",[e._v("一个sentinel接收另一个sentinel发来的"),t("code",[e._v("is-master-down-by-addr")]),e._v("后，提取参数，根据ip和端口，检测Master是否已"),t("code",[e._v("主观下线")]),e._v("。并且回复"),t("code",[e._v("is-master-down-by-addr")]),e._v("，回复包含三个参数：")]),e._v(" "),t("ul",[t("li",[e._v("down_state：返回目标Sentinel对Master的检查结果，1代表主服务器已下线，0代表主服务器未下线")]),e._v(" "),t("li",[e._v("leader_runid：Sentinel运行ID用于选举领头Sentinel")]),e._v(" "),t("li",[e._v("leader_epoch：领头sentinel纪元")])]),e._v(" "),t("p",[e._v("sentinel接收到回复后，根据配置设置的下线最小数量，达到这个值，既认为该服务客观下线。")]),e._v(" "),t("p",[t("strong",[e._v("客观下线条件只适用于主服务器")]),e._v("： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。只要一个 Sentinel 发现某个主服务器进入了客观下线状态， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对失效的主服务器执行自动故障迁移操作，故障转移是自动完成的。")]),e._v(" "),t("h2",{attrs:{id:"配置传播"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置传播"}},[e._v("#")]),e._v(" 配置传播")]),e._v(" "),t("p",[e._v("一旦一个sentinel成功地对一个master进行了"),t("code",[e._v("failover(故障转移)")]),e._v("，它将会把关于master的最新配置通过广播形式通知其它sentinel，其它的sentinel则更新对应master的配置。\n一个faiover(故障转移)要想被成功实行，sentinel必须能够向选为master的slave发送"),t("code",[e._v("SLAVEOF NO ONE")]),e._v("命令，然后能够通过INFO命令看到新master的配置信息。\n当将一个slave选举为master并发送"),t("code",[e._v("SLAVEOF NO ONE")]),e._v("后，即使其它的slave还没针对新master重新配置自己，failover也被认为是成功了的，然后所有sentinels将会发布新的配置信息。\n新配在集群中相互传播的方式，就是为什么我们需要当一个sentinel进行failover时必须被授权一个版本号的原因。\n每个sentinel使用##发布/订阅##的方式持续地传播master的配置版本信息，配置传播的##发布/订阅##管道是："),t("strong",[e._v("sentinel")]),e._v(":hello。\n因为每一个配置都有一个版本号，所以以版本号最大的那个为标准。")]),e._v(" "),t("p",[e._v("举个例子：\n假设有一个名为mymaster的地址为192.168.10.202:6379。一开始，集群中所有的sentinel都知道这个地址，于是为mymaster的配置打上版本号1。一段时候后mymaster死了，有一个sentinel被授权用版本号2对其进行failover。如果failover成功了，假设地址改为了192.168.10.202:9000，此时配置的版本号为2，进行failover的sentinel会将新配置广播给其他的sentinel，由于其他sentinel维护的版本号为1，发现新配置的版本号为2时，版本号变大了，说明配置更新了，于是就会采用最新的版本号为2的配置。\n这意味着sentinel集群保证了第二种活跃性：一个能够互相通信的sentinel集群最终会采用版本号最高且相同的配置。")]),e._v(" "),t("h2",{attrs:{id:"sentinel的-仲裁会"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sentinel的-仲裁会"}},[e._v("#")]),e._v(" sentinel的“仲裁会”")]),e._v(" "),t("p",[e._v("前面我们谈到，当一个master被sentinel集群监控时，需要为它指定一个参数，这个参数指定了当需要判决master为不可用，并且进行failover(故障转移)时，所需要的sentinel数量，可以称这个参数为票数")]),e._v(" "),t("p",[e._v("不过，当failover(故障转移)主备切换真正被触发后，failover(故障转移)并不会马上进行，还需要sentinel中的大多数sentinel授权后才可以进行failover。\n当"),t("code",[e._v("ODOWN")]),e._v("时，failover被触发。failover一旦被触发，尝试去进行failover的sentinel会去获得“大多数”sentinel的授权（如果票数比大多数还要大的时候，则询问更多的sentinel)\n这个区别看起来很微妙，但是很容易理解和使用。例如，集群中有5个sentinel，票数被设置为2，当2个sentinel认为一个master已经不可用了以后，将会触发failover，但是，进行failover的那个sentinel必须先获得至少3个sentinel的授权才可以实行failover。\n如果票数被设置为5，要达到ODOWN状态，必须所有5个sentinel都主观认为master为不可用，要进行failover，那么得获得所有5个sentinel的授权。")]),e._v(" "),t("h2",{attrs:{id:"slave选举与优先级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#slave选举与优先级"}},[e._v("#")]),e._v(" Slave选举与优先级")]),e._v(" "),t("p",[e._v("当一个sentinel准备好了要进行failover，并且收到了其他sentinel的授权，那么就需要选举出一个合适的slave来做为新的master。")]),e._v(" "),t("p",[e._v("slave的选举主要会评估slave的以下几个方面：")]),e._v(" "),t("ul",[t("li",[e._v("与master断开连接的次数")]),e._v(" "),t("li",[e._v("Slave的优先级")]),e._v(" "),t("li",[e._v("数据复制的下标(用来评估slave当前拥有多少master的数据)")]),e._v(" "),t("li",[e._v("进程ID")])]),e._v(" "),t("p",[e._v("如果一个slave与master失去联系超过10次，并且每次都超过了配置的最大失联时间(down-after-milliseconds)，如果sentinel在进行failover时发现slave失联，那么这个slave就会被sentinel认为不适合用来做新master的。\n更严格的定义是，如果一个slave持续断开连接的时间超过\n(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state\n就会被认为失去选举资格。")]),e._v(" "),t("p",[e._v("符合上述条件的slave才会被列入master候选人列表，并根据以下顺序来进行排序：")]),e._v(" "),t("ul",[t("li",[e._v("sentinel首先会根据slaves的优先级来进行排序，优先级越小排名越靠前。")]),e._v(" "),t("li",[e._v("如果优先级相同，则查看复制的下标，哪个从master接收的复制数据多，哪个就靠前。")]),e._v(" "),t("li",[e._v("如果优先级和下标都相同，就选择进程ID较小的那个。")])]),e._v(" "),t("p",[e._v("一个redis无论是master还是slave，都必须在配置中指定一个slave优先级。要注意到master也是有可能通过failover变成slave的。\n如果一个redis的slave优先级配置为0，那么它将永远不会被选为master。但是它依然会从master哪里复制数据。")])])}),[],!1,null,null,null);s.default=a.exports}}]);